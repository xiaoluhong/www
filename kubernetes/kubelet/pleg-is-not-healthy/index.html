<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PLEG is not healthy (一) | IT老男孩</title><meta name="keywords" content="IT老男孩,rancher,github rancher,rke,rke2,k3s,docker,kubernetes,devops,多集群管理,容器,Linux运维,网络运维,最佳实践,PLEG,kubelet,PLEG,kubelet"><meta name="author" content="IT老男孩"><meta name="copyright" content="IT老男孩"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文永久链接: https:&#x2F;&#x2F;www.xtplayer.cn&#x2F;kubernetes&#x2F;kubelet&#x2F;pleg-is-not-healthy&#x2F;  PLEG 是什么？PLEG 全称叫 Pod Lifecycle Event Generator，即 Pod 生命周期事件生成器。实际上它只是 Kubelet 中的一个模块，主要职责就是通过匹配每个的 Pod 事件级别来调整容器运行时的状态，并将调整的结果"><meta property="og:type" content="article"><meta property="og:title" content="PLEG is not healthy (一)"><meta property="og:url" content="https://www.xtplayer.cn/kubernetes/kubelet/pleg-is-not-healthy/index.html"><meta property="og:site_name" content="IT老男孩"><meta property="og:description" content="本文永久链接: https:&#x2F;&#x2F;www.xtplayer.cn&#x2F;kubernetes&#x2F;kubelet&#x2F;pleg-is-not-healthy&#x2F;  PLEG 是什么？PLEG 全称叫 Pod Lifecycle Event Generator，即 Pod 生命周期事件生成器。实际上它只是 Kubelet 中的一个模块，主要职责就是通过匹配每个的 Pod 事件级别来调整容器运行时的状态，并将调整的结果"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.xtplayer.cn/img/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-09-11T10:12:04.000Z"><meta property="article:modified_time" content="2021-02-04T17:33:40.000Z"><meta property="article:author" content="IT老男孩"><meta property="article:tag" content="PLEG"><meta property="article:tag" content="kubelet"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.xtplayer.cn/img/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" type="image/png" href="/img/favicon.png"><link rel="canonical" href="https://www.xtplayer.cn/kubernetes/kubelet/pleg-is-not-healthy/"><link rel="preconnect" href="https//cdn.jsdelivr.net"><link rel="preconnect" href="https//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="https//hm.baidu.com"><link rel="preconnect" href="https//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet preload" as="font" href="/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/css/snackbar.min.css" media="print" onload='this.media="all"'><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-4244806813321801",enable_page_level_ads:"true"})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?08d495d3996be233cf4355e47874fd02";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-WDVQSZ43MX"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-WDVQSZ43MX")</script><script>!function(){var c=document.createElement("script");c.src="https://sf1-scmcdn-tos.pstatp.com/goofy/ttzz/push.js?abca38a75f1ee646121b4cdefd4e13ce89e669412cb977bb98b66029e7fc3cfc8d38a1f1352cfca035e8cdfca27dc395b6c71280cecfa54b697791769b400b8d",c.id="ttzz";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(c,e)}(window)</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-center"},source:{jQuery:"/js/jquery.min.js",justifiedGallery:{js:"/js/jquery.justifiedGallery.min.js",css:"/css/justifiedGallery.min.css"},fancybox:{js:"/js/jquery.fancybox.min.js",css:"/css/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-02-05 01:33:40"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)});const t=saveToLocal.get("aside-status");void 0!==t&&("hide"===t?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><style>#toggle-sidebar{left:100px}</style><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="IT老男孩" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' width="110px" height="110px" alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">132</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">96</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/ad/"><i class="fa-fw fas fa-heart"></i> <span>广告</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">IT老男孩</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/ad/"><i class="fa-fw fas fa-heart"></i> <span>广告</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div class="ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4244806813321801" data-ad-slot="4594418186" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div id="post-info"><h1 class="post-title">PLEG is not healthy (一)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表:</span> <time class="post-meta-date-created" datetime="2020-09-11T10:12:04.000Z" title="发表 2020-09-11 18:12:04">2020-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新:</span> <time class="post-meta-date-updated" datetime="2021-02-04T17:33:40.000Z" title="更新 2021-02-05 01:33:40">2021-02-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><span class="post-meta-label">分类:</span> <a class="post-meta-categories" href="/categories/kubernetes/">kubernetes</a><i class="fas fa-angle-right post-meta-separator"></i><a class="post-meta-categories" href="/categories/kubernetes/kubelet/">kubelet</a></span><span class="post-meta tags"><span class="post-meta-separator">|</span><i class="fas fa-tag post-meta-icon"></i><span class="post-meta-label">标签:</span> <a class="post-meta-tags" href="/tags/pleg/">PLEG</a><span class="post-meta__link">•</span><a class="post-meta-tags" href="/tags/kubelet/">kubelet</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span> <span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span> <span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="PLEG is not healthy (一)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p><span>本文永久链接:</span><i class="fa fa-creative-commons"></i> <a rel="noopener external nofollow noreferrer" href="https://www.xtplayer.cn/kubernetes/kubelet/pleg-is-not-healthy/" target="_blank" title="https://www.xtplayer.cn/kubernetes/kubelet/pleg-is-not-healthy/">https://www.xtplayer.cn/kubernetes/kubelet/pleg-is-not-healthy/</a></p><h2 id="PLEG-是什么？"><a href="#PLEG-是什么？" class="headerlink" title="PLEG 是什么？"></a>PLEG 是什么？</h2><p>PLEG 全称叫 <code>Pod Lifecycle Event Generator</code>，即 Pod 生命周期事件生成器。实际上它只是 <code>Kubelet</code> 中的一个模块，主要职责就是通过匹配每个的 Pod 事件级别来调整容器运行时的状态，并将调整的结果写入缓存，使 <code>Pod</code> 的缓存保持最新状态。</p><h2 id="PLEG-出现的背景"><a href="#PLEG-出现的背景" class="headerlink" title="PLEG 出现的背景"></a>PLEG 出现的背景</h2><p>在 Kubernetes 中，每个节点上都运行着守护进程 <code>Kubelet</code> 来管理节点上的容器，调整容器的实际状态以匹配 <code>spec</code> 中定义的状态。具体来说，Kubelet 需要对两个地方的更改做出及时的回应:</p><ul><li>Pod spec 中定义的状态</li><li>容器运行时的状态</li></ul><p>对于 Pod，Kubelet 会从多个数据来源 <code>watch</code> Pod spec 中的变化。对于容器，Kubelet 会定期（例如，10s）轮询容器运行时，以获取所有容器的最新状态。</p><p>随着 Pod 和容器数量的增加，轮询会产生不可忽略的开销，并且会由于 Kubelet 的并行操作而加剧这种开销（为每个 Pod 分配一个 <code>goruntine</code>，用来获取容器的状态）。轮询带来的周期性大量并发请求会导致较高的 CPU 使用率峰值（即使 Pod 的定义和容器的状态没有发生改变），降低性能。最后容器运行时可能不堪重负，从而降低系统的可靠性，限制 Kubelet 的可扩展性。</p><p>为了降低 Pod 的管理开销，提升 Kubelet 的性能和可扩展性，引入了 PLEG，改进了之前的工作方式：</p><ul><li>减少空闲期间的不必要工作（例如 Pod 的定义和容器的状态没有发生更改）。</li><li>减少获取容器状态的并发请求数量。</li></ul><p>整体的工作流程如下图所示，虚线部分是 PLEG 的工作内容:</p><img src="/kubernetes/kubelet/pleg-is-not-healthy/ykjn32j5n8.png" title="ykjn32j5n8"><h2 id="PLEG-is-not-healthy-是如何发生？"><a href="#PLEG-is-not-healthy-是如何发生？" class="headerlink" title="PLEG is not healthy 是如何发生？"></a>PLEG is not healthy 是如何发生？</h2><p><code>Healthy()</code> 函数会以 “PLEG” 的形式添加到 <code>runtimeState</code> 中，Kubelet 在一个同步循环（<code>SyncLoop()</code> 函数）中会定期（默认是 10s）调用 <code>Healthy()</code> 函数。<code>Healthy()</code> 函数会检查 <code>relist</code> 进程（PLEG 的关键任务）是否在 3 分钟内完成。如果 relist 进程的完成时间超过 3 分钟，就会报告 <strong>PLEG is not healthy</strong>。</p><img src="/kubernetes/kubelet/pleg-is-not-healthy/0lwunp8jgm.png" title="0lwunp8jgm"><h2 id="PLEG-工作流程"><a href="#PLEG-工作流程" class="headerlink" title="PLEG 工作流程"></a>PLEG 工作流程</h2><p>以下流程的每一步通过源代码解释其相关的工作原理，源代码基于 Kubernetes 1.11。</p><h3 id="Healthy-函数"><a href="#Healthy-函数" class="headerlink" title="Healthy() 函数"></a>Healthy() 函数</h3><p>healthy() 函数的相关代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - Healthy()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The threshold needs to be greater than the relisting period + the</span></span><br><span class="line"><span class="comment">// relisting time, which can vary significantly. Set a conservative</span></span><br><span class="line"><span class="comment">// threshold to avoid flipping between healthy and unhealthy.</span></span><br><span class="line">relistThreshold = <span class="number">3</span> * time.<span class="property">Minute</span></span><br><span class="line">:</span><br><span class="line">func (g *<span class="title class_">GenericPLEG</span>) <span class="title class_">Healthy</span>() (bool, error) &#123;</span><br><span class="line">  relistTime := g.<span class="title function_">getRelistTime</span>()</span><br><span class="line">  elapsed := g.<span class="property">clock</span>.<span class="title class_">Since</span>(relistTime)</span><br><span class="line">  <span class="keyword">if</span> elapsed &gt; relistThreshold &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, fmt.<span class="title class_">Errorf</span>(<span class="string">&quot;pleg was last seen active %v ago; threshold is %v&quot;</span>, elapsed, relistThreshold)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/kubelet.go - NewMainKubelet()</span></span><br><span class="line">func <span class="title class_">NewMainKubelet</span>(kubeCfg *kubeletconfiginternal.<span class="property">KubeletConfiguration</span>, ...</span><br><span class="line">:</span><br><span class="line">  klet.<span class="property">runtimeState</span>.<span class="title function_">addHealthCheck</span>(<span class="string">&quot;PLEG&quot;</span>, klet.<span class="property">pleg</span>.<span class="property">Healthy</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/kubelet.go - syncLoop()</span></span><br><span class="line">func (kl *<span class="title class_">Kubelet</span>) <span class="title function_">syncLoop</span>(<span class="params">updates &lt;-chan kubetypes.PodUpdate, handler SyncHandler</span>) &#123;</span><br><span class="line">:</span><br><span class="line"><span class="comment">// The resyncTicker wakes up kubelet to checks if there are any pod workers</span></span><br><span class="line"><span class="comment">// that need to be sync&#x27;d. A one-second period is sufficient because the</span></span><br><span class="line"><span class="comment">// sync interval is defaulted to 10s.</span></span><br><span class="line">:</span><br><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">    base   = <span class="number">100</span> * time.<span class="property">Millisecond</span></span><br><span class="line">    max    = <span class="number">5</span> * time.<span class="property">Second</span></span><br><span class="line">    factor = <span class="number">2</span></span><br><span class="line">  )</span><br><span class="line">  duration := base</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> rs := kl.<span class="property">runtimeState</span>.<span class="title function_">runtimeErrors</span>(); <span class="title function_">len</span>(rs) != <span class="number">0</span> &#123;</span><br><span class="line">          glog.<span class="title class_">Infof</span>(<span class="string">&quot;skipping pod synchronization - %v&quot;</span>, rs)</span><br><span class="line">          <span class="comment">// exponential backoff</span></span><br><span class="line">          time.<span class="title class_">Sleep</span>(duration)</span><br><span class="line">          duration = time.<span class="title class_">Duration</span>(math.<span class="title class_">Min</span>(<span class="title function_">float64</span>(max), factor*<span class="title function_">float64</span>(duration)))</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">    :</span><br><span class="line">  &#125;</span><br><span class="line">:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/runtime.go - runtimeErrors()</span></span><br><span class="line">func (s *runtimeState) <span class="title function_">runtimeErrors</span>() []string &#123;</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">for</span> _, hc := range s.<span class="property">healthChecks</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ok, err := hc.<span class="title function_">fn</span>(); !ok &#123;</span><br><span class="line">            ret = <span class="title function_">append</span>(ret, fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;%s is not healthy: %v&quot;</span>, hc.<span class="property">name</span>, err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="relist-函数"><a href="#relist-函数" class="headerlink" title="relist 函数"></a>relist 函数</h3><p>上文提到 <code>healthy()</code> 函数会检查 <strong>relist</strong> 的完成时间，但 <strong>relist</strong> 究竟是用来干嘛的呢？解释 relist 之前，要先解释一下 Pod 的生命周期事件。Pod 的生命周期事件是在 Pod 层面上对底层容器状态改变的抽象，使其与底层的容器运行时无关，这样就可以让 Kubelet 不受底层容器运行时的影响。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">PodLifeCycleEventType</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="title class_">ContainerStarted</span>      <span class="title class_">PodLifeCycleEventType</span> = <span class="string">&quot;ContainerStarted&quot;</span></span><br><span class="line">    <span class="title class_">ContainerStopped</span>      <span class="title class_">PodLifeCycleEventType</span> = <span class="string">&quot;ContainerStopped&quot;</span></span><br><span class="line">    <span class="title class_">NetworkSetupCompleted</span> <span class="title class_">PodLifeCycleEventType</span> = <span class="string">&quot;NetworkSetupCompleted&quot;</span></span><br><span class="line">    <span class="title class_">NetworkFailed</span>         <span class="title class_">PodLifeCycleEventType</span> = <span class="string">&quot;NetworkFailed&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// PodLifecycleEvent is an event reflects the change of the pod state.</span></span><br><span class="line">type <span class="title class_">PodLifecycleEvent</span> struct &#123;</span><br><span class="line">    <span class="comment">// The pod ID.</span></span><br><span class="line">    <span class="variable constant_">ID</span> types.<span class="property">UID</span></span><br><span class="line">    <span class="comment">// The type of the event.</span></span><br><span class="line">    <span class="title class_">Type</span> <span class="title class_">PodLifeCycleEventType</span></span><br><span class="line">    <span class="comment">// The accompanied data which varies based on the event type.</span></span><br><span class="line">    <span class="title class_">Data</span> interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 Docker 为例，在 Pod 中启动一个 <strong>infra</strong> 容器就会在 Kubelet 中注册一个 <code>NetworkSetupCompleted</code> Pod 生命周期事件。</p><ul><li>那么 PLEG 是如何知道新启动了一个 infra 容器呢？</li></ul><p>它会定期重新列出节点上的所有容器（例如：<strong>docker ps</strong>），并与上一次的容器列表进行对比，以此来判断容器状态的变化。其实这就是 <code>relist()</code> 函数干的事情，尽管这种方法和以前的 Kubelet 轮询类似，但现在只有一个线程，就是 PLEG。现在不需要所有的线程并发获取容器的状态，只有相关的线程会被唤醒用来同步容器状态。而且 <strong>relist</strong> 与容器运行时无关，也不需要外部依赖。</p><p>下面来看一下 <code>relist()</code> 函数的内部实现，完整的流程如下图所示：</p><img src="/kubernetes/kubelet/pleg-is-not-healthy/pleg-process.png" title="img"><p>注意图中的 <strong>RPC</strong> 调用部分，后文将会详细说明。完整的源代码 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/openshift/origin/blob/release-3.11/vendor/k8s.io/kubernetes/pkg/kubelet/pleg/generic.go#L180-L284%E3%80%82">https://github.com/openshift/origin/blob/release-3.11/vendor/k8s.io/kubernetes/pkg/kubelet/pleg/generic.go#L180-L284。</a></p><ol><li>尽管每秒钟调用一次 <code>relist</code>，但它的完成时间仍然有可能超过 1s。因为下一次调用 <code>relist</code> 必须得等上一次 relist 执行结束，设想一下，如果容器运行时响应缓慢，或者一个周期内有大量的容器状态发生改变，那么 <code>relist</code> 的完成时间将不可忽略，假设是 5s，那么下一次调用 <code>relist</code> 将要等到 6s 之后。</li></ol><img src="/kubernetes/kubelet/pleg-is-not-healthy/pleg-start-relist.png" title="img"><p>相关的源代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// pkg/kubelet/kubelet.go - NewMainKubelet()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic PLEG relies on relisting for discovering container events.</span></span><br><span class="line"><span class="comment">// A longer period means that kubelet will take longer to detect container</span></span><br><span class="line"><span class="comment">// changes and to update pod status. On the other hand, a shorter period</span></span><br><span class="line"><span class="comment">// will cause more frequent relisting (e.g., container runtime operations),</span></span><br><span class="line"><span class="comment">// leading to higher cpu usage.</span></span><br><span class="line"><span class="comment">// Note that even though we set the period to 1s, the relisting itself can</span></span><br><span class="line"><span class="comment">// take more than 1s to finish if the container runtime responds slowly</span></span><br><span class="line"><span class="comment">// and/or when there are many container changes in one cycle.</span></span><br><span class="line">plegRelistPeriod = time.<span class="property">Second</span> * <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMainKubelet instantiates a new Kubelet object along with all the required internal modules.</span></span><br><span class="line"><span class="comment">// No initialization of Kubelet and its modules should happen here.</span></span><br><span class="line">func <span class="title class_">NewMainKubelet</span>(kubeCfg *kubeletconfiginternal.<span class="property">KubeletConfiguration</span>, ...</span><br><span class="line">:</span><br><span class="line">  klet.<span class="property">pleg</span> = pleg.<span class="title class_">NewGenericPLEG</span>(klet.<span class="property">containerRuntime</span>, plegChannelCapacity, plegRelistPeriod, klet.<span class="property">podCache</span>, clock.<span class="property">RealClock</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - Start()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start spawns a goroutine to relist periodically.</span></span><br><span class="line">func (g *<span class="title class_">GenericPLEG</span>) <span class="title class_">Start</span>() &#123;</span><br><span class="line">  go wait.<span class="title class_">Until</span>(g.<span class="property">relist</span>, g.<span class="property">relistPeriod</span>, wait.<span class="property">NeverStop</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - relist()</span></span><br><span class="line">func (g *<span class="title class_">GenericPLEG</span>) <span class="title function_">relist</span>(<span class="params"></span>) &#123;</span><br><span class="line">... <span class="variable constant_">WE</span> <span class="variable constant_">WILL</span> <span class="variable constant_">REVIEW</span> <span class="variable constant_">HERE</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>回到上面那幅图，<strong>relist</strong> 函数第一步就是记录 <code>Kubelet</code> 的相关指标（例如 <code>kubelet_pleg_relist_latency_microseconds</code>），然后通过 CRI 从容器运行时获取当前的 Pod 列表（包括停止的 Pod）。该 Pod 列表会和之前的 Pod 列表进行比较，检查哪些状态发生了变化，然后同时生成相关的 <strong>Pod 生命周期事件</strong>和<strong>更改后的状态</strong>。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - relist()</span></span><br><span class="line">  :</span><br><span class="line">  <span class="comment">// get a current timestamp</span></span><br><span class="line">  timestamp := g.<span class="property">clock</span>.<span class="title class_">Now</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// kubelet_pleg_relist_latency_microseconds for prometheus metrics</span></span><br><span class="line">    defer <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">        metrics.<span class="property">PLEGRelistLatency</span>.<span class="title class_">Observe</span>(metrics.<span class="title class_">SinceInMicroseconds</span>(timestamp))</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get all the pods.</span></span><br><span class="line">    podList, err := g.<span class="property">runtime</span>.<span class="title class_">GetPods</span>(<span class="literal">true</span>)</span><br><span class="line">  :</span><br></pre></td></tr></table></figure><p>其中 <code>GetPods()</code> 函数的调用堆栈如下图所示：</p><img src="/kubernetes/kubelet/pleg-is-not-healthy/pleg-getpods.png" title="img"><p>相关的源代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// pkg/kubelet/kuberuntime/kuberuntime_manager.go - GetPods()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPods returns a list of containers grouped by pods. The boolean parameter</span></span><br><span class="line"><span class="comment">// specifies whether the runtime returns all containers including those already</span></span><br><span class="line"><span class="comment">// exited and dead containers (used for garbage collection).</span></span><br><span class="line">func (m *kubeGenericRuntimeManager) <span class="title class_">GetPods</span>(all bool) ([]*kubecontainer.<span class="property">Pod</span>, error) &#123;</span><br><span class="line">    pods := <span class="title function_">make</span>(map[kubetypes.<span class="property">UID</span>]*kubecontainer.<span class="property">Pod</span>)</span><br><span class="line">    sandboxes, err := m.<span class="title function_">getKubeletSandboxes</span>(all)</span><br><span class="line">:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/kuberuntime/kuberuntime_sandbox.go - getKubeletSandboxes()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getKubeletSandboxes lists all (or just the running) sandboxes managed by kubelet.</span></span><br><span class="line">func (m *kubeGenericRuntimeManager) <span class="title function_">getKubeletSandboxes</span>(all bool) ([]*runtimeapi.<span class="property">PodSandbox</span>, error) &#123;</span><br><span class="line">:</span><br><span class="line">    resp, err := m.<span class="property">runtimeService</span>.<span class="title class_">ListPodSandbox</span>(filter)</span><br><span class="line">:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/remote/remote_runtime.go - ListPodSandbox()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ListPodSandbox returns a list of PodSandboxes.</span></span><br><span class="line">func (r *<span class="title class_">RemoteRuntimeService</span>) <span class="title class_">ListPodSandbox</span>(filter *runtimeapi.<span class="property">PodSandboxFilter</span>) ([]*runtimeapi.<span class="property">PodSandbox</span>, error) &#123;</span><br><span class="line">:</span><br><span class="line">    resp, err := r.<span class="property">runtimeClient</span>.<span class="title class_">ListPodSandbox</span>(ctx, &amp;runtimeapi.<span class="property">ListPodSandboxRequest</span>&#123;</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">return</span> resp.<span class="property">Items</span>, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取所有的 Pod 列表后，<code>relist</code> 的完成时间就会更新成当前的时间戳。也就是说，<code>Healthy()</code> 函数可以根据这个时间戳来评估 relist 是否超过了 3 分钟。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - relist()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// update as a current timestamp</span></span><br><span class="line">  g.<span class="title function_">updateRelistTime</span>(timestamp)</span><br></pre></td></tr></table></figure><ol><li><p>将当前的 Pod 列表和上一次 relist 的 Pod 列表进行对比之后，就会针对每一个变化生成相应的 Pod 级别的事件。</p><p>其中 <code>generateEvents()</code> 函数（<code>computeEvents()</code> 函数会调用它）用来生成相应的 Pod 级别的事件（例如 <code>ContainerStarted</code>、<code>ContainerDied</code> 等等），然后通过 <code>updateEvents()</code> 函数来更新事件。</p><p>相关的源代码如下：</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - relist()</span></span><br><span class="line"></span><br><span class="line">  pods := kubecontainer.<span class="title class_">Pods</span>(podList)</span><br><span class="line">  g.<span class="property">podRecords</span>.<span class="title function_">setCurrent</span>(pods)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compare the old and the current pods, and generate events.</span></span><br><span class="line">  eventsByPodID := map[types.<span class="property">UID</span>][]*<span class="title class_">PodLifecycleEvent</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> pid := range g.<span class="property">podRecords</span> &#123;</span><br><span class="line">    oldPod := g.<span class="property">podRecords</span>.<span class="title function_">getOld</span>(pid)</span><br><span class="line">    pod := g.<span class="property">podRecords</span>.<span class="title function_">getCurrent</span>(pid)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get all containers in the old and the new pod.</span></span><br><span class="line">    allContainers := <span class="title function_">getContainersFromPods</span>(oldPod, pod)</span><br><span class="line">    <span class="keyword">for</span> _, container := range allContainers &#123;</span><br><span class="line">          events := <span class="title function_">computeEvents</span>(oldPod, pod, &amp;container.<span class="property">ID</span>)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> _, e := range events &#123;</span><br><span class="line">                <span class="title function_">updateEvents</span>(eventsByPodID, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​ <code>computeEvents()</code> 函数的内容如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - computeEvents()</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">computeEvents</span>(oldPod, newPod *kubecontainer.<span class="property">Pod</span>, cid *kubecontainer.<span class="property">ContainerID</span>) []*<span class="title class_">PodLifecycleEvent</span> &#123;</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">generateEvents</span>(pid, cid.<span class="property">ID</span>, oldState, newState)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - generateEvents()</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">generateEvents</span>(podID types.<span class="property">UID</span>, cid string, oldState, newState plegContainerState) []*<span class="title class_">PodLifecycleEvent</span> &#123;</span><br><span class="line">:</span><br><span class="line">    glog.<span class="title function_">V</span>(<span class="number">4</span>).<span class="title class_">Infof</span>(<span class="string">&quot;GenericPLEG: %v/%v: %v -&gt; %v&quot;</span>, podID, cid, oldState, newState)</span><br><span class="line">    <span class="keyword">switch</span> newState &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">plegContainerRunning</span>:</span><br><span class="line">      <span class="keyword">return</span> []*<span class="title class_">PodLifecycleEvent</span>&#123;&#123;<span class="attr">ID</span>: podID, <span class="title class_">Type</span>: <span class="title class_">ContainerStarted</span>, <span class="title class_">Data</span>: cid&#125;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">plegContainerExited</span>:</span><br><span class="line">      <span class="keyword">return</span> []*<span class="title class_">PodLifecycleEvent</span>&#123;&#123;<span class="attr">ID</span>: podID, <span class="title class_">Type</span>: <span class="title class_">ContainerDied</span>, <span class="title class_">Data</span>: cid&#125;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">plegContainerUnknown</span>:</span><br><span class="line">      <span class="keyword">return</span> []*<span class="title class_">PodLifecycleEvent</span>&#123;&#123;<span class="attr">ID</span>: podID, <span class="title class_">Type</span>: <span class="title class_">ContainerChanged</span>, <span class="title class_">Data</span>: cid&#125;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">plegContainerNonExistent</span>:</span><br><span class="line">      <span class="keyword">switch</span> oldState &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">plegContainerExited</span>:</span><br><span class="line">        <span class="comment">// We already reported that the container died before.</span></span><br><span class="line">        <span class="keyword">return</span> []*<span class="title class_">PodLifecycleEvent</span>&#123;&#123;<span class="attr">ID</span>: podID, <span class="title class_">Type</span>: <span class="title class_">ContainerRemoved</span>, <span class="title class_">Data</span>: cid&#125;&#125;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> []*<span class="title class_">PodLifecycleEvent</span>&#123;&#123;<span class="attr">ID</span>: podID, <span class="title class_">Type</span>: <span class="title class_">ContainerDied</span>, <span class="title class_">Data</span>: cid&#125;, &#123;<span class="attr">ID</span>: podID, <span class="title class_">Type</span>: <span class="title class_">ContainerRemoved</span>, <span class="title class_">Data</span>: cid&#125;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="title function_">panic</span>(fmt.<span class="title class_">Sprintf</span>(<span class="string">&quot;unrecognized container state: %v&quot;</span>, newState))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>relist 的最后一个任务是检查是否有与 Pod 关联的事件，并按照下面的流程更新 <code>podCache</code>。</p><p><code>updateCache()</code> 将会检查每个 Pod，并在单个循环中依次对其进行更新。因此，如果在同一个 relist 中更改了大量的 Pod，那么 updateCache 过程将会成为瓶颈。最后，更新后的 Pod 生命周期事件将会被发送到 <code>eventChannel</code>。</p><p>某些远程客户端还会调用每一个 Pod 来获取 Pod 的 spec 定义信息，这样一来，Pod 数量越多，延时就可能越高，因为 Pod 越多就会生成越多的事件。</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - relist()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there are events associated with a pod, we should update the</span></span><br><span class="line">  <span class="comment">// podCache.</span></span><br><span class="line">  <span class="keyword">for</span> pid, events := range eventsByPodID &#123;</span><br><span class="line">    pod := g.<span class="property">podRecords</span>.<span class="title function_">getCurrent</span>(pid)</span><br><span class="line">    <span class="keyword">if</span> g.<span class="title function_">cacheEnabled</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// updateCache() will inspect the pod and update the cache. If an</span></span><br><span class="line">      <span class="comment">// error occurs during the inspection, we want PLEG to retry again</span></span><br><span class="line">      <span class="comment">// in the next relist. To achieve this, we do not update the</span></span><br><span class="line">      <span class="comment">// associated podRecord of the pod, so that the change will be</span></span><br><span class="line">      <span class="comment">// detect again in the next relist.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> If many pods changed during the same relist period,</span></span><br><span class="line">      <span class="comment">// inspecting the pod and getting the PodStatus to update the cache</span></span><br><span class="line">      <span class="comment">// serially may take a while. We should be aware of this and</span></span><br><span class="line">      <span class="comment">// parallelize if needed.</span></span><br><span class="line">      <span class="keyword">if</span> err := g.<span class="title function_">updateCache</span>(pod, pid); err != nil &#123;</span><br><span class="line">        glog.<span class="title class_">Errorf</span>(<span class="string">&quot;PLEG: Ignoring events for pod %s/%s: %v&quot;</span>, pod.<span class="property">Name</span>, pod.<span class="property">Namespace</span>, err)</span><br><span class="line">        :</span><br><span class="line">      &#125;</span><br><span class="line">      :</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Update the internal storage and send out the events.</span></span><br><span class="line">    g.<span class="property">podRecords</span>.<span class="title function_">update</span>(pid)</span><br><span class="line">    <span class="keyword">for</span> i := range events &#123;</span><br><span class="line">      <span class="comment">// Filter out events that are not reliable and no other components use yet.</span></span><br><span class="line">      <span class="keyword">if</span> events[i].<span class="property">Type</span> == <span class="title class_">ContainerChanged</span> &#123;</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      g.<span class="property">eventChannel</span> &lt;- events[i]</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​ <code>updateCache()</code> 的详细调用堆栈如下图所示，其中 <code>GetPodStatus()</code> 用来获取 Pod 的 spec 定义信息：</p><img src="/kubernetes/kubelet/pleg-is-not-healthy/pleg-updatecache.png" title="img"><p>​ 相关代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// pkg/kubelet/pleg/generic.go - updateCache()</span></span><br><span class="line"></span><br><span class="line">func (g *<span class="title class_">GenericPLEG</span>) <span class="title function_">updateCache</span>(pod *kubecontainer.<span class="property">Pod</span>, pid types.<span class="property">UID</span>) error &#123;</span><br><span class="line">:</span><br><span class="line">    timestamp := g.<span class="property">clock</span>.<span class="title class_">Now</span>()</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Consider adding a new runtime method</span></span><br><span class="line">    <span class="comment">// GetPodStatus(pod *kubecontainer.Pod) so that Docker can avoid listing</span></span><br><span class="line">    <span class="comment">// all containers again.</span></span><br><span class="line">    status, err := g.<span class="property">runtime</span>.<span class="title class_">GetPodStatus</span>(pod.<span class="property">ID</span>, pod.<span class="property">Name</span>, pod.<span class="property">Namespace</span>)</span><br><span class="line">  :</span><br><span class="line">    g.<span class="property">cache</span>.<span class="title class_">Set</span>(pod.<span class="property">ID</span>, status, err, timestamp)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/kuberuntime/kuberuntime_manager.go - GetPodStatus()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPodStatus retrieves the status of the pod, including the</span></span><br><span class="line"><span class="comment">// information of all containers in the pod that are visible in Runtime.</span></span><br><span class="line">func (m *kubeGenericRuntimeManager) <span class="title class_">GetPodStatus</span>(uid kubetypes.<span class="property">UID</span>, name, namespace string) (*kubecontainer.<span class="property">PodStatus</span>, error) &#123;</span><br><span class="line">  podSandboxIDs, err := m.<span class="title function_">getSandboxIDByPodUID</span>(uid, nil)</span><br><span class="line">  :</span><br><span class="line">    <span class="keyword">for</span> idx, podSandboxID := range podSandboxIDs &#123;</span><br><span class="line">        podSandboxStatus, err := m.<span class="property">runtimeService</span>.<span class="title class_">PodSandboxStatus</span>(podSandboxID)</span><br><span class="line">    :</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get statuses of all containers visible in the pod.</span></span><br><span class="line">    containerStatuses, err := m.<span class="title function_">getPodContainerStatuses</span>(uid, name, namespace)</span><br><span class="line">  :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/kuberuntime/kuberuntime_sandbox.go - getSandboxIDByPodUID()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getPodSandboxID gets the sandbox id by podUID and returns ([]sandboxID, error).</span></span><br><span class="line"><span class="comment">// Param state could be nil in order to get all sandboxes belonging to same pod.</span></span><br><span class="line">func (m *kubeGenericRuntimeManager) <span class="title function_">getSandboxIDByPodUID</span>(podUID kubetypes.<span class="property">UID</span>, state *runtimeapi.<span class="property">PodSandboxState</span>) ([]string, error) &#123;</span><br><span class="line">  :</span><br><span class="line">  sandboxes, err := m.<span class="property">runtimeService</span>.<span class="title class_">ListPodSandbox</span>(filter)</span><br><span class="line">  :</span><br><span class="line">  <span class="keyword">return</span> sandboxIDs, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/remote/remote_runtime.go - PodSandboxStatus()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PodSandboxStatus returns the status of the PodSandbox.</span></span><br><span class="line">func (r *<span class="title class_">RemoteRuntimeService</span>) <span class="title class_">PodSandboxStatus</span>(podSandBoxID string) (*runtimeapi.<span class="property">PodSandboxStatus</span>, error) &#123;</span><br><span class="line">    ctx, cancel := <span class="title function_">getContextWithTimeout</span>(r.<span class="property">timeout</span>)</span><br><span class="line">    defer <span class="title function_">cancel</span>()</span><br><span class="line"></span><br><span class="line">    resp, err := r.<span class="property">runtimeClient</span>.<span class="title class_">PodSandboxStatus</span>(ctx, &amp;runtimeapi.<span class="property">PodSandboxStatusRequest</span>&#123;</span><br><span class="line">        <span class="title class_">PodSandboxId</span>: podSandBoxID,</span><br><span class="line">    &#125;)</span><br><span class="line">  :</span><br><span class="line">    <span class="keyword">return</span> resp.<span class="property">Status</span>, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// pkg/kubelet/kuberuntime/kuberuntime_container.go - getPodContainerStatuses()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getPodContainerStatuses gets all containers&#x27; statuses for the pod.</span></span><br><span class="line">func (m *kubeGenericRuntimeManager) <span class="title function_">getPodContainerStatuses</span>(uid kubetypes.<span class="property">UID</span>, name, namespace string) ([]*kubecontainer.<span class="property">ContainerStatus</span>, error) &#123;</span><br><span class="line">  <span class="comment">// Select all containers of the given pod.</span></span><br><span class="line">  containers, err := m.<span class="property">runtimeService</span>.<span class="title class_">ListContainers</span>(&amp;runtimeapi.<span class="property">ContainerFilter</span>&#123;</span><br><span class="line">    <span class="title class_">LabelSelector</span>: map[string]string&#123;types.<span class="property">KubernetesPodUIDLabel</span>: <span class="title function_">string</span>(uid)&#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  :</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> optimization: set maximum number of containers per container name to examine.</span></span><br><span class="line">  <span class="keyword">for</span> i, c := range containers &#123;</span><br><span class="line">    status, err := m.<span class="property">runtimeService</span>.<span class="title class_">ContainerStatus</span>(c.<span class="property">Id</span>)</span><br><span class="line">    :</span><br><span class="line">  &#125;</span><br><span class="line">  :</span><br><span class="line">  <span class="keyword">return</span> statuses, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监控-relist"><a href="#监控-relist" class="headerlink" title="监控 relist"></a>监控 relist</h3><p>我们可以通过监控 Kubelet 的指标来了解 <code>relist</code> 的延时。<code>relist</code> 的调用周期是 1s，那么 <strong>relist 的完成时间 + 1s</strong> 就等于 <code>kubelet_pleg_relist_interval_microseconds</code> 指标的值。你也可以监控容器运行时每个操作的延时，这些指标在排查故障时都能提供线索。</p><img src="/kubernetes/kubelet/pleg-is-not-healthy/pleg-kubelet-metrics-table.png" title="img"><p>你可以在每个节点上通过访问 URL <code>https://127.0.0.1:10250/metrics</code> 来获取 Kubelet 的指标。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># <span class="variable constant_">HELP</span> kubelet_pleg_relist_interval_microseconds <span class="title class_">Interval</span> <span class="keyword">in</span> microseconds between relisting <span class="keyword">in</span> <span class="variable constant_">PLEG</span>.</span><br><span class="line"># <span class="variable constant_">TYPE</span> kubelet_pleg_relist_interval_microseconds summary</span><br><span class="line">kubelet_pleg_relist_interval_microseconds&#123;quantile=<span class="string">&quot;0.5&quot;</span>&#125; <span class="number">1.054052e+06</span></span><br><span class="line">kubelet_pleg_relist_interval_microseconds&#123;quantile=<span class="string">&quot;0.9&quot;</span>&#125; <span class="number">1.074873e+06</span></span><br><span class="line">kubelet_pleg_relist_interval_microseconds&#123;quantile=<span class="string">&quot;0.99&quot;</span>&#125; <span class="number">1.126039e+06</span></span><br><span class="line">kubelet_pleg_relist_interval_microseconds_count <span class="number">5146</span></span><br><span class="line"></span><br><span class="line"># <span class="variable constant_">HELP</span> kubelet_pleg_relist_latency_microseconds <span class="title class_">Latency</span> <span class="keyword">in</span> microseconds <span class="keyword">for</span> relisting pods <span class="keyword">in</span> <span class="variable constant_">PLEG</span>.</span><br><span class="line"># <span class="variable constant_">TYPE</span> kubelet_pleg_relist_latency_microseconds summary</span><br><span class="line">kubelet_pleg_relist_latency_microseconds&#123;quantile=<span class="string">&quot;0.5&quot;</span>&#125; <span class="number">53438</span></span><br><span class="line">kubelet_pleg_relist_latency_microseconds&#123;quantile=<span class="string">&quot;0.9&quot;</span>&#125; <span class="number">74396</span></span><br><span class="line">kubelet_pleg_relist_latency_microseconds&#123;quantile=<span class="string">&quot;0.99&quot;</span>&#125; <span class="number">115232</span></span><br><span class="line">kubelet_pleg_relist_latency_microseconds_count <span class="number">5106</span></span><br><span class="line"></span><br><span class="line"># <span class="variable constant_">HELP</span> kubelet_runtime_operations <span class="title class_">Cumulative</span> number <span class="keyword">of</span> runtime operations by operation type.</span><br><span class="line"># <span class="variable constant_">TYPE</span> kubelet_runtime_operations counter</span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;container_status&quot;</span>&#125; <span class="number">472</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;create_container&quot;</span>&#125; <span class="number">93</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;exec&quot;</span>&#125; <span class="number">1</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;exec_sync&quot;</span>&#125; <span class="number">533</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;image_status&quot;</span>&#125; <span class="number">579</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;list_containers&quot;</span>&#125; <span class="number">10249</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;list_images&quot;</span>&#125; <span class="number">782</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;list_podsandbox&quot;</span>&#125; <span class="number">10154</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;podsandbox_status&quot;</span>&#125; <span class="number">315</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;pull_image&quot;</span>&#125; <span class="number">57</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;remove_container&quot;</span>&#125; <span class="number">49</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;run_podsandbox&quot;</span>&#125; <span class="number">28</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;start_container&quot;</span>&#125; <span class="number">93</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;status&quot;</span>&#125; <span class="number">1116</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;stop_container&quot;</span>&#125; <span class="number">9</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;stop_podsandbox&quot;</span>&#125; <span class="number">33</span></span><br><span class="line">kubelet_runtime_operations&#123;operation_type=<span class="string">&quot;version&quot;</span>&#125; <span class="number">564</span></span><br><span class="line"></span><br><span class="line"># <span class="variable constant_">HELP</span> kubelet_runtime_operations_latency_microseconds <span class="title class_">Latency</span> <span class="keyword">in</span> microseconds <span class="keyword">of</span> runtime operations. <span class="title class_">Broken</span> down by operation type.</span><br><span class="line"># <span class="variable constant_">TYPE</span> kubelet_runtime_operations_latency_microseconds summary</span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;container_status&quot;</span>,quantile=<span class="string">&quot;0.5&quot;</span>&#125; <span class="number">12117</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;container_status&quot;</span>,quantile=<span class="string">&quot;0.9&quot;</span>&#125; <span class="number">26607</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;container_status&quot;</span>,quantile=<span class="string">&quot;0.99&quot;</span>&#125; <span class="number">27598</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds_count&#123;operation_type=<span class="string">&quot;container_status&quot;</span>&#125; <span class="number">486</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;list_containers&quot;</span>,quantile=<span class="string">&quot;0.5&quot;</span>&#125; <span class="number">29972</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;list_containers&quot;</span>,quantile=<span class="string">&quot;0.9&quot;</span>&#125; <span class="number">47907</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;list_containers&quot;</span>,quantile=<span class="string">&quot;0.99&quot;</span>&#125; <span class="number">80982</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds_count&#123;operation_type=<span class="string">&quot;list_containers&quot;</span>&#125; <span class="number">10812</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;list_podsandbox&quot;</span>,quantile=<span class="string">&quot;0.5&quot;</span>&#125; <span class="number">18053</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;list_podsandbox&quot;</span>,quantile=<span class="string">&quot;0.9&quot;</span>&#125; <span class="number">28116</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;list_podsandbox&quot;</span>,quantile=<span class="string">&quot;0.99&quot;</span>&#125; <span class="number">68748</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds_count&#123;operation_type=<span class="string">&quot;list_podsandbox&quot;</span>&#125; <span class="number">10712</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;podsandbox_status&quot;</span>,quantile=<span class="string">&quot;0.5&quot;</span>&#125; <span class="number">4918</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;podsandbox_status&quot;</span>,quantile=<span class="string">&quot;0.9&quot;</span>&#125; <span class="number">15671</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds&#123;operation_type=<span class="string">&quot;podsandbox_status&quot;</span>,quantile=<span class="string">&quot;0.99&quot;</span>&#125; <span class="number">18398</span></span><br><span class="line">kubelet_runtime_operations_latency_microseconds_count&#123;operation_type=<span class="string">&quot;podsandbox_status&quot;</span>&#125; <span class="number">323</span></span><br></pre></td></tr></table></figure><p>可以通过 Prometheus 对其进行监控：</p><img src="/kubernetes/kubelet/pleg-is-not-healthy/pleg-prometheus-metrics.png" title="img"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>造成 <strong>PLEG is not healthy</strong> 的因素有很多，出现最多的原因：</p><ul><li>RPC 调用过程中容器运行时响应超时（有可能是性能下降，死锁或者出现了 bug）。</li><li>节点上的 Pod 数量太多，导致 <code>relist</code> 无法在 3 分钟内完成。事件数量和延时与 Pod 数量成正比，与节点资源无关。</li><li>relist 出现了死锁，该 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kubernetes/kubernetes/issues/72482">bug</a> 已在 Kubernetes 1.14 中修复。</li><li>获取 Pod 的网络堆栈信息时 CNI 出现了 bug。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.redhat.com/blog/2019/11/13/pod-lifecycle-event-generator-understanding-the-pleg-is-not-healthy-issue-in-kubernetes/">https://developers.redhat.com/blog/2019/11/13/pod-lifecycle-event-generator-understanding-the-pleg-is-not-healthy-issue-in-kubernetes/</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kubernetes/kubernetes/issues/72482">https://github.com/kubernetes/kubernetes/issues/72482</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/runtime-pod-cache.md">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/runtime-pod-cache.md</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/openshift/origin/blob/release-3.11/vendor/k8s.io/kubernetes/pkg/kubelet/pleg/generic.go#L180-L284">https://github.com/openshift/origin/blob/release-3.11/vendor/k8s.io/kubernetes/pkg/kubelet/pleg/generic.go#L180-L284</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">IT老男孩</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://www.xtplayer.cn/kubernetes/kubelet/pleg-is-not-healthy/">https://www.xtplayer.cn/kubernetes/kubelet/pleg-is-not-healthy/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a rel="noopener noreferrer" href="https://www.xtplayer.cn" target="_blank">IT老男孩</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pleg/">PLEG</a><a class="post-meta__tags" href="/tags/kubelet/">kubelet</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/kubernetes/kubelet/pleg-is-not-healthy-2/"><img class="prev-cover" src="/img/gkihqEjXxJ5UZ1C.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PLEG is not healthy（二）</div></div></a></div><div class="next-post pull-right"><a href="/rancher/authentication/rancher2-okta-authentication/"><img class="next-cover" src="/img/gkihqEjXxJ5UZ1C.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Rancher2 配置 okta 认证</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/kubernetes/kubelet/pleg-is-not-healthy-2/" title="PLEG is not healthy（二）"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-15</div><div class="title">PLEG is not healthy（二）</div></div></a></div><div><a href="/kubernetes/about-kubernetes-1.20/" title="了解 Kubernetes 1.20"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-15</div><div class="title">了解 Kubernetes 1.20</div></div></a></div><div><a href="/kubernetes/api-server-and-etcd-health-state-check/" title="Api Server 和 ETCD 健康状态检查"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-22</div><div class="title">Api Server 和 ETCD 健康状态检查</div></div></a></div><div><a href="/kubernetes/automatic-k8s-deployment-tool/" title="K8S 自动部署工具"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-06</div><div class="title">K8S 自动部署工具</div></div></a></div><div><a href="/kubernetes/autoscaling/" title="Kubernetes 规范中标签的重要性"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-19</div><div class="title">Kubernetes 规范中标签的重要性</div></div></a></div><div><a href="/kubernetes/concepts-and-matters/" title="Kubernetes 概念及其重要性"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-15</div><div class="title">Kubernetes 概念及其重要性</div></div></a></div><div><a href="/kubernetes/controller-manager-and-scheduler-unavailable/" title="记一次 controller manager and scheduler unavailable 问题分析"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-24</div><div class="title">记一次 controller manager and scheduler unavailable 问题分析</div></div></a></div><div><a href="/kubernetes/custom-serviceaccount/" title="自定义服务账户（Service Account）"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-09</div><div class="title">自定义服务账户（Service Account）</div></div></a></div><div><a href="/kubernetes/docker-credentials-secret/" title="记一次镜像仓库凭证相关问题分析"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-23</div><div class="title">记一次镜像仓库凭证相关问题分析</div></div></a></div><div><a href="/kubernetes/fast-migration-pod-when-node-unavailable/" title="K8S 节点不可用时快速迁移 Pods"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-16</div><div class="title">K8S 节点不可用时快速迁移 Pods</div></div></a></div><div><a href="/kubernetes/forces-delete-terminated-namespace/" title="强制删除 Terminating 状态的 namespace"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-01</div><div class="title">强制删除 Terminating 状态的 namespace</div></div></a></div><div><a href="/kubernetes/ingress-configuration-demo/" title="Ingress 常用配置（持续更新）"><img class="cover" src="/img/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-11</div><div class="title">Ingress 常用配置（持续更新）</div></div></a></div></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4244806813321801" data-ad-slot="9845679202" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' width="110px" height="110px" alt="avatar"><div class="author-info__name">IT老男孩</div><div class="author-info__description">IT老男孩 - 原名系统玩家，分享 IT 相关技术文章，分享工作中的最佳实践。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">132</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">96</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/rancher"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xiaoluhong" target="_blank" rel="external nofollow noreferrer noopener" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1044281310@qq.com" target="_blank" rel="external nofollow noreferrer noopener" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录导航</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PLEG-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">PLEG 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PLEG-%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">PLEG 出现的背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PLEG-is-not-healthy-%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">PLEG is not healthy 是如何发生？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PLEG-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">PLEG 工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Healthy-%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">Healthy() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#relist-%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">relist 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7-relist"><span class="toc-number">4.3.</span> <span class="toc-text">监控 relist</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rancher/waiting-for-node-to-register-either-cluster-is-not-ready-for-registering-or-etcd-and-controlplane-node-have-to-be-registered-first/" title="Waiting for node to register. Either cluster is not ready for registering or etcd and controlplane node have to be registered first">Waiting for node to register. Either cluster is not ready for registering or etcd and controlplane node have to be registered first</a><time datetime="2022-09-17T06:33:50.000Z" title="发表 2022-09-17 14:33:50">2022-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/mysql/how-to-get-the-sizes-of-the-tables-of-a-mysql-database/" title="如何查看 MySQL 数据库容量大小，表容量大小，索引容量大小？">如何查看 MySQL 数据库容量大小，表容量大小，索引容量大小？</a><time datetime="2022-05-17T08:48:50.000Z" title="发表 2022-05-17 16:48:50">2022-05-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rancher/either-cluster-is-not-ready-for-registering/" title="node-agent 报错 Either cluster is not ready for registering, cluster is currently provisioning, or etcd, controlplane and worker node have to be registered">node-agent 报错 Either cluster is not ready for registering, cluster is currently provisioning, or etcd, controlplane and worker node have to be registered</a><time datetime="2022-05-14T05:13:09.000Z" title="发表 2022-05-14 13:13:09">2022-05-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/prometheus/prometheus-adapter/" title="Prometheus Adapter 安装">Prometheus Adapter 安装</a><time datetime="2022-04-04T08:26:12.000Z" title="发表 2022-04-04 16:26:12">2022-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/prometheus/custom-parameter/" title="自定义集群监控参数">自定义集群监控参数</a><time datetime="2022-03-28T11:10:20.000Z" title="发表 2022-03-28 19:10:20">2022-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rancher/rancher-new-forums/" title="全新论坛启用，Rancher 中文社区迈入新阶段">全新论坛启用，Rancher 中文社区迈入新阶段</a><time datetime="2022-03-25T13:16:03.000Z" title="发表 2022-03-25 21:16:03">2022-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/coredns/accelerate-external-domain-resolution/" title="coreDNS 加速外部域名解析">coreDNS 加速外部域名解析</a><time datetime="2021-07-17T05:12:27.000Z" title="发表 2021-07-17 13:12:27">2021-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/longhorn/ai-at-the-edge-with-k3s-nvidia-jetson-nano-object-detection-real-time-video-analytics-src/" title="AI at the Edge with K3s and NVIDIA Jetson Nano: Object Detection and Real-Time Video Analytics">AI at the Edge with K3s and NVIDIA Jetson Nano: Object Detection and Real-Time Video Analytics</a><time datetime="2021-04-20T16:22:57.000Z" title="发表 2021-04-21 00:22:57">2021-04-21</time></div></div></div></div><div class="card-widget ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4244806813321801" data-ad-slot="5141213090" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By IT老男孩</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn"><img class="icp-icon" width="25px" height="17px" src="/img/icp.png" alt="icp"><span>蜀ICP备20023095号-1</span></a> <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51010702002006"><span>川公网安备51010702002006号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text" aria-label="Search"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/instantpage.min.js" type="module"></script><script src="/js/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="5169987169" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="/css/APlayer.min.css" media="print" onload='this.media="all"'><script src="/js/APlayer.min.js"></script><script src="/js/Meting.min.js"></script><script src="/js/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!0,scrollRestoration:!1});document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","G-WDVQSZ43MX",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:send",(function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="/js/busuanzi.pure.mini.js"></script><script>!function(){var e=document.createElement("script");e.src="https://sf1-scmcdn-tos.pstatp.com/goofy/ttzz/push.js?abca38a75f1ee646121b4cdefd4e13cef04782c449861f0dbdffcd879911999e0ea61db5c17bca91cb6b39891e5c5ae8de9c557b8186e0f895b49e96a4810ca7",e.id="ttzz";var c=document.getElementsByTagName("script")[0];c.parentNode.insertBefore(e,c)}(window)</script></div></body></html>